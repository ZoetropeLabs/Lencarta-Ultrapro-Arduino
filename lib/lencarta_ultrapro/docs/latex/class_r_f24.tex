\hypertarget{class_r_f24}{\section{R\+F24 Class Reference}
\label{class_r_f24}\index{R\+F24@{R\+F24}}
}


{\ttfamily \#include $<$R\+F24.\+h$>$}

\subsection*{Public Member Functions}
\begin{Indent}{\bf Primary public interface}\par
{\em These are the main methods you need to operate the chip }\begin{DoxyCompactItemize}
\item 
\hyperlink{class_r_f24_a8cd165a822c8f77e10782c6729c5b088}{R\+F24} (uint8\+\_\+t \+\_\+cepin, uint8\+\_\+t \+\_\+cspin)
\item 
void \hyperlink{class_r_f24_a9e720d303ad594de611a813c69244517}{begin} (void)
\item 
void \hyperlink{class_r_f24_a30a2733a3889bdc331fe2d2f4f0f7b39}{start\+Listening} (void)
\item 
void \hyperlink{class_r_f24_a6f144d73fc447c8ac2d1a4166210fd88}{stop\+Listening} (void)
\item 
bool \hyperlink{class_r_f24_a127105eb7a3b351cfe777c1cec50627a}{available} (void)
\item 
void \hyperlink{class_r_f24_a8e2eacacfba96426c192066f04054c5b}{read} (void $\ast$buf, uint8\+\_\+t len)
\item 
bool \hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write} (const void $\ast$buf, uint8\+\_\+t len)
\item 
void \hyperlink{class_r_f24_af2e409e62d49a23e372a70b904ae30e1}{open\+Writing\+Pipe} (const uint8\+\_\+t $\ast$address)
\item 
void \hyperlink{class_r_f24_a9edc910ccc1ffcff56814b08faca5535}{open\+Reading\+Pipe} (uint8\+\_\+t number, const uint8\+\_\+t $\ast$address)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Advanced Operation}\par
{\em Methods you can use to drive the chip in more advanced ways }\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_r_f24_adc95213ed4c8569a90eb33122e16cea6}{print\+Details} (void)
\item 
bool \hyperlink{class_r_f24_ace7dd139fabc16b77cb8325faa07620f}{available} (uint8\+\_\+t $\ast$pipe\+\_\+num)
\item 
bool \hyperlink{class_r_f24_ad22e44fe1a68747872fcb304a407fd30}{rx\+Fifo\+Full} ()
\item 
void \hyperlink{class_r_f24_aa0a51923a09ba4f3478aba9be0f8a6a1}{power\+Down} (void)
\item 
void \hyperlink{class_r_f24_a5cdaf47aa0edd6dca1b9a8bb7972a1a3}{power\+Up} (void)
\item 
bool \hyperlink{class_r_f24_a23bfe6502d74bb5bbccb3a7f2ba2b5ea}{write} (const void $\ast$buf, uint8\+\_\+t len, const bool multicast)
\item 
bool \hyperlink{class_r_f24_a47b2516993481b58e724d1274a7fd9cb}{write\+Fast} (const void $\ast$buf, uint8\+\_\+t len)
\item 
bool \hyperlink{class_r_f24_ad16d53de0327c0b41d170cbda4bf41af}{write\+Fast} (const void $\ast$buf, uint8\+\_\+t len, const bool multicast)
\item 
bool \hyperlink{class_r_f24_ae6fd8d5ee490d54ae1cb2e8fefee535f}{write\+Blocking} (const void $\ast$buf, uint8\+\_\+t len, uint32\+\_\+t timeout)
\item 
bool \hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{tx\+Stand\+By} ()
\item 
bool \hyperlink{class_r_f24_aa6f36353c1bdfbaf3c530d118cb84baa}{tx\+Stand\+By} (uint32\+\_\+t timeout)
\item 
void \hyperlink{class_r_f24_a65619238c25036c3de72dc2c1a1c6e52}{write\+Ack\+Payload} (uint8\+\_\+t pipe, const void $\ast$buf, uint8\+\_\+t len)
\item 
void \hyperlink{class_r_f24_a6253607ac2a1995af91a35cea6899c31}{enable\+Dynamic\+Ack} ()
\item 
bool \hyperlink{class_r_f24_a30c2736fd0df9c8128cef408c8b88e92}{is\+Ack\+Payload\+Available} (void)
\item 
void \hyperlink{class_r_f24_afb97dc4bdf4d2d84ea44060ac5b4ed89}{what\+Happened} (bool \&tx\+\_\+ok, bool \&tx\+\_\+fail, bool \&rx\+\_\+ready)
\item 
void \hyperlink{class_r_f24_a7f27a53cda5f707c817c9a89a8425489}{start\+Fast\+Write} (const void $\ast$buf, uint8\+\_\+t len, const bool multicast)
\item 
void \hyperlink{class_r_f24_aa27519fc289920094422033e0bbf8cf9}{start\+Write} (const void $\ast$buf, uint8\+\_\+t len, const bool multicast)
\item 
void \hyperlink{class_r_f24_aeaf7fa54d3ab2a85ce215b4bf6ae933b}{re\+Use\+T\+X} ()
\item 
uint8\+\_\+t \hyperlink{class_r_f24_adb7915b1d2661a82137573344f659e81}{flush\+\_\+tx} (void)
\item 
bool \hyperlink{class_r_f24_ad0d522ccf39493510e64bf1740be790d}{test\+Carrier} (void)
\item 
bool \hyperlink{class_r_f24_a821285f3b54553f4402eb3fd0ac6d6c1}{test\+R\+P\+D} (void)
\item 
bool \hyperlink{class_r_f24_a35e5f1533b7753806c42b76e782d917e}{is\+Valid} ()
\item 
void \hyperlink{class_r_f24_abf68b9b0c9cd17179e9e144c3e7f9c45}{mask\+I\+R\+Q} (bool tx\+\_\+ok, bool tx\+\_\+fail, bool rx\+\_\+ready)
\item 
void \hyperlink{class_r_f24_ad5aea7f9a3bd9c7d357fb296ce751f21}{set\+Address\+Width} (uint8\+\_\+t a\+\_\+width)
\item 
void \hyperlink{class_r_f24_a9944d93994a80037e3586f340f5e0107}{close\+Reading\+Pipe} (uint8\+\_\+t pipe)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Deprecated}\par
{\em Methods provided for backwards compabibility. }\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_r_f24_aa7e8523f86f9f8f20c274e0c89a5fd45}{open\+Reading\+Pipe} (uint8\+\_\+t number, uint64\+\_\+t address)
\item 
void \hyperlink{class_r_f24_a50c8e68ee840e1860a31dbdc83afbd77}{open\+Writing\+Pipe} (uint64\+\_\+t address)
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Optional Configurators}
\label{_amgrpe1a83b99ec8153e5baf680edeeed1586}%
 Methods you can use to get or set the configuration of the chip. None are required. Calling \hyperlink{class_r_f24_a9e720d303ad594de611a813c69244517}{begin()} sets up a reasonable set of defaults. \begin{DoxyCompactItemize}
\item 
bool \hyperlink{class_r_f24_a2e40fe66d1231a333aa2534e8491f828}{failure\+Detected}
\item 
void \hyperlink{class_r_f24_a4c6d3959c8320e64568395f4ef507aef}{set\+Retries} (uint8\+\_\+t delay, uint8\+\_\+t count)
\item 
void \hyperlink{class_r_f24_a5e6e5a5f6c85d2638381cab2c0f3702e}{set\+Channel} (uint8\+\_\+t channel)
\item 
void \hyperlink{class_r_f24_a343e5d23477181011dea030fafb1954f}{set\+Payload\+Size} (uint8\+\_\+t size)
\item 
uint8\+\_\+t \hyperlink{class_r_f24_a0aa0c7cbe3d38fef4722f3f1d2d6c5f1}{get\+Payload\+Size} (void)
\item 
uint8\+\_\+t \hyperlink{class_r_f24_a65963ed8d8fd45f847e2f673995b85e1}{get\+Dynamic\+Payload\+Size} (void)
\item 
void \hyperlink{class_r_f24_abf8efced2ee9edbcc6510878b20edc1b}{enable\+Ack\+Payload} (void)
\item 
void \hyperlink{class_r_f24_a443888504975d7441d6452a09d09a8fa}{enable\+Dynamic\+Payloads} (void)
\item 
bool \hyperlink{class_r_f24_a62846750b82682beb7593719eb60ed60}{is\+P\+Variant} (void)
\item 
void \hyperlink{class_r_f24_aec71746d59da978bcbb975167886a2cc}{set\+Auto\+Ack} (bool enable)
\item 
void \hyperlink{class_r_f24_a60dba9e558f3620ab489af68ea3dea9c}{set\+Auto\+Ack} (uint8\+\_\+t pipe, bool enable)
\item 
void \hyperlink{class_r_f24_adedac579590a668ae97baccab284de8a}{set\+P\+A\+Level} (uint8\+\_\+t level)
\item 
uint8\+\_\+t \hyperlink{class_r_f24_af7c4dcd84466168c5816382ceb366067}{get\+P\+A\+Level} (void)
\item 
bool \hyperlink{class_r_f24_aeb9920e7a95699748b003c4a839b0814}{set\+Data\+Rate} (\hyperlink{_r_f24_8h_a82745de4aa1251b7561564b3ed1d6522}{rf24\+\_\+datarate\+\_\+e} speed)
\item 
\hyperlink{_r_f24_8h_a82745de4aa1251b7561564b3ed1d6522}{rf24\+\_\+datarate\+\_\+e} \hyperlink{class_r_f24_a72a7b11dafe8ffab6135f243decce0d7}{get\+Data\+Rate} (void)
\item 
void \hyperlink{class_r_f24_a89f626fc4a58dd997153bcc0f8198b9e}{set\+C\+R\+C\+Length} (\hyperlink{_r_f24_8h_adbe00719f3f835c82bd007081d040a7e}{rf24\+\_\+crclength\+\_\+e} length)
\item 
\hyperlink{_r_f24_8h_adbe00719f3f835c82bd007081d040a7e}{rf24\+\_\+crclength\+\_\+e} \hyperlink{class_r_f24_aba4ca91b829afcd94a4c11e0343e3796}{get\+C\+R\+C\+Length} (void)
\item 
void \hyperlink{class_r_f24_a5eacd9ecfbc19864801d714c292cf8be}{disable\+C\+R\+C} (void)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Driver for n\+R\+F24\+L01(+) 2.\+4\+G\+Hz Wireless Transceiver 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_r_f24_a8cd165a822c8f77e10782c6729c5b088}{\index{R\+F24@{R\+F24}!R\+F24@{R\+F24}}
\index{R\+F24@{R\+F24}!R\+F24@{R\+F24}}
\subsubsection[{R\+F24}]{\setlength{\rightskip}{0pt plus 5cm}R\+F24\+::\+R\+F24 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{\+\_\+cepin, }
\item[{uint8\+\_\+t}]{\+\_\+cspin}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a8cd165a822c8f77e10782c6729c5b088}
Constructor

Creates a new instance of this driver. Before using, you create an instance and send in the unique pins that this chip is connected to.


\begin{DoxyParams}{Parameters}
{\em \+\_\+cepin} & The pin attached to Chip Enable on the R\+F module \\
\hline
{\em \+\_\+cspin} & The pin attached to Chip Select \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{class_r_f24_a127105eb7a3b351cfe777c1cec50627a}{\index{R\+F24@{R\+F24}!available@{available}}
\index{available@{available}!R\+F24@{R\+F24}}
\subsubsection[{available}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::available (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a127105eb7a3b351cfe777c1cec50627a}
Test whether there are bytes available to be read

\begin{DoxyReturn}{Returns}
True if there is a payload available, false if none is 
\end{DoxyReturn}
\hypertarget{class_r_f24_ace7dd139fabc16b77cb8325faa07620f}{\index{R\+F24@{R\+F24}!available@{available}}
\index{available@{available}!R\+F24@{R\+F24}}
\subsubsection[{available}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::available (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$}]{pipe\+\_\+num}
\end{DoxyParamCaption}
)}}\label{class_r_f24_ace7dd139fabc16b77cb8325faa07620f}
Test whether there are bytes available to be read in the F\+I\+F\+O buffers. This optimized version does not rely on interrupt flags, but checks the actual F\+I\+F\+O buffers.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em pipe\+\_\+num} & Which pipe has the payload available \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if there is a payload available, false if none is 
\end{DoxyReturn}
\hypertarget{class_r_f24_a9e720d303ad594de611a813c69244517}{\index{R\+F24@{R\+F24}!begin@{begin}}
\index{begin@{begin}!R\+F24@{R\+F24}}
\subsubsection[{begin}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::begin (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a9e720d303ad594de611a813c69244517}
Begin operation of the chip

Call this in setup(), before calling any other methods. \hypertarget{class_r_f24_a9944d93994a80037e3586f340f5e0107}{\index{R\+F24@{R\+F24}!close\+Reading\+Pipe@{close\+Reading\+Pipe}}
\index{close\+Reading\+Pipe@{close\+Reading\+Pipe}!R\+F24@{R\+F24}}
\subsubsection[{close\+Reading\+Pipe}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::close\+Reading\+Pipe (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{pipe}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a9944d93994a80037e3586f340f5e0107}
Close a pipe after it has been previously opened. Can be safely called without having previously opened a pipe. 
\begin{DoxyParams}{Parameters}
{\em pipe} & Which pipe \# to close, 0-\/5. \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a5eacd9ecfbc19864801d714c292cf8be}{\index{R\+F24@{R\+F24}!disable\+C\+R\+C@{disable\+C\+R\+C}}
\index{disable\+C\+R\+C@{disable\+C\+R\+C}!R\+F24@{R\+F24}}
\subsubsection[{disable\+C\+R\+C}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::disable\+C\+R\+C (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a5eacd9ecfbc19864801d714c292cf8be}
Disable C\+R\+C validation \hypertarget{class_r_f24_abf8efced2ee9edbcc6510878b20edc1b}{\index{R\+F24@{R\+F24}!enable\+Ack\+Payload@{enable\+Ack\+Payload}}
\index{enable\+Ack\+Payload@{enable\+Ack\+Payload}!R\+F24@{R\+F24}}
\subsubsection[{enable\+Ack\+Payload}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::enable\+Ack\+Payload (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_abf8efced2ee9edbcc6510878b20edc1b}
Enable custom payloads on the acknowledge packets

Ack payloads are a handy way to return data back to senders without manually changing the radio modes on both units.

\begin{DoxySeeAlso}{See also}
examples/\+Getting\+Started\+\_\+\+Call\+Response/\+Getting\+Started\+\_\+\+Call\+Response.\+ino 
\end{DoxySeeAlso}
\hypertarget{class_r_f24_a6253607ac2a1995af91a35cea6899c31}{\index{R\+F24@{R\+F24}!enable\+Dynamic\+Ack@{enable\+Dynamic\+Ack}}
\index{enable\+Dynamic\+Ack@{enable\+Dynamic\+Ack}!R\+F24@{R\+F24}}
\subsubsection[{enable\+Dynamic\+Ack}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::enable\+Dynamic\+Ack (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a6253607ac2a1995af91a35cea6899c31}
Enable dynamic A\+C\+Ks (single write multicasting) for chosen messages

\begin{DoxyNote}{Note}
To enable full multicasting or per-\/pipe multicast, use \hyperlink{class_r_f24_aec71746d59da978bcbb975167886a2cc}{set\+Auto\+Ack()}
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
This M\+U\+S\+T be called prior to attempting single write N\+O\+A\+C\+K calls 
\begin{DoxyCode}
radio.enableDynamicAck();
radio.write(&data,32,1);  \textcolor{comment}{// Sends a payload with no acknowledgement requested}
radio.write(&data,32,0);  \textcolor{comment}{// Sends a payload using auto-retry/autoACK}
\end{DoxyCode}
 
\end{DoxyWarning}
\hypertarget{class_r_f24_a443888504975d7441d6452a09d09a8fa}{\index{R\+F24@{R\+F24}!enable\+Dynamic\+Payloads@{enable\+Dynamic\+Payloads}}
\index{enable\+Dynamic\+Payloads@{enable\+Dynamic\+Payloads}!R\+F24@{R\+F24}}
\subsubsection[{enable\+Dynamic\+Payloads}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::enable\+Dynamic\+Payloads (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a443888504975d7441d6452a09d09a8fa}
Enable dynamically-\/sized payloads

This way you don't always have to send large packets just to send them once in a while. This enables dynamic payloads on A\+L\+L pipes.

\begin{DoxySeeAlso}{See also}
examples/pingpair\+\_\+pl/pingpair\+\_\+dyn.\+pde 
\end{DoxySeeAlso}
\hypertarget{class_r_f24_adb7915b1d2661a82137573344f659e81}{\index{R\+F24@{R\+F24}!flush\+\_\+tx@{flush\+\_\+tx}}
\index{flush\+\_\+tx@{flush\+\_\+tx}!R\+F24@{R\+F24}}
\subsubsection[{flush\+\_\+tx}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t R\+F24\+::flush\+\_\+tx (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_adb7915b1d2661a82137573344f659e81}
Empty the transmit buffer

\begin{DoxyReturn}{Returns}
Current value of status register 
\end{DoxyReturn}
\hypertarget{class_r_f24_aba4ca91b829afcd94a4c11e0343e3796}{\index{R\+F24@{R\+F24}!get\+C\+R\+C\+Length@{get\+C\+R\+C\+Length}}
\index{get\+C\+R\+C\+Length@{get\+C\+R\+C\+Length}!R\+F24@{R\+F24}}
\subsubsection[{get\+C\+R\+C\+Length}]{\setlength{\rightskip}{0pt plus 5cm}{\bf rf24\+\_\+crclength\+\_\+e} R\+F24\+::get\+C\+R\+C\+Length (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_aba4ca91b829afcd94a4c11e0343e3796}
Get the C\+R\+C length

\begin{DoxyReturn}{Returns}
R\+F24\+\_\+\+D\+I\+S\+A\+B\+L\+E\+D if disabled or R\+F24\+\_\+\+C\+R\+C\+\_\+8 for 8-\/bit or R\+F24\+\_\+\+C\+R\+C\+\_\+16 for 16-\/bit 
\end{DoxyReturn}
\hypertarget{class_r_f24_a72a7b11dafe8ffab6135f243decce0d7}{\index{R\+F24@{R\+F24}!get\+Data\+Rate@{get\+Data\+Rate}}
\index{get\+Data\+Rate@{get\+Data\+Rate}!R\+F24@{R\+F24}}
\subsubsection[{get\+Data\+Rate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf rf24\+\_\+datarate\+\_\+e} R\+F24\+::get\+Data\+Rate (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a72a7b11dafe8ffab6135f243decce0d7}
Fetches the transmission data rate

\begin{DoxyReturn}{Returns}
Returns the hardware's currently configured datarate. The value is one of 250kbs, R\+F24\+\_\+1\+M\+B\+P\+S for 1\+Mbps, or R\+F24\+\_\+2\+M\+B\+P\+S, as defined in the rf24\+\_\+datarate\+\_\+e enum. 
\end{DoxyReturn}
\hypertarget{class_r_f24_a65963ed8d8fd45f847e2f673995b85e1}{\index{R\+F24@{R\+F24}!get\+Dynamic\+Payload\+Size@{get\+Dynamic\+Payload\+Size}}
\index{get\+Dynamic\+Payload\+Size@{get\+Dynamic\+Payload\+Size}!R\+F24@{R\+F24}}
\subsubsection[{get\+Dynamic\+Payload\+Size}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t R\+F24\+::get\+Dynamic\+Payload\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a65963ed8d8fd45f847e2f673995b85e1}
Get Dynamic Payload Size

For dynamic payloads, this pulls the size of the payload off the chip

\begin{DoxyNote}{Note}
Corrupt packets are now detected and flushed per the manufacturer.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
Payload length of last-\/received dynamic payload 
\end{DoxyReturn}
\hypertarget{class_r_f24_af7c4dcd84466168c5816382ceb366067}{\index{R\+F24@{R\+F24}!get\+P\+A\+Level@{get\+P\+A\+Level}}
\index{get\+P\+A\+Level@{get\+P\+A\+Level}!R\+F24@{R\+F24}}
\subsubsection[{get\+P\+A\+Level}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t R\+F24\+::get\+P\+A\+Level (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_af7c4dcd84466168c5816382ceb366067}
Fetches the current P\+A level.

N\+R\+F24\+L01\+: -\/18d\+Bm, -\/12d\+Bm, -\/6d\+Bm and 0d\+Bm S\+I24\+R1\+: -\/6d\+Bm, 0d\+Bm, 3d\+Bm, 7d\+Bm

\begin{DoxyReturn}{Returns}
Returns values 0 to 3 representing the P\+A Level. 
\end{DoxyReturn}
\hypertarget{class_r_f24_a0aa0c7cbe3d38fef4722f3f1d2d6c5f1}{\index{R\+F24@{R\+F24}!get\+Payload\+Size@{get\+Payload\+Size}}
\index{get\+Payload\+Size@{get\+Payload\+Size}!R\+F24@{R\+F24}}
\subsubsection[{get\+Payload\+Size}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t R\+F24\+::get\+Payload\+Size (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a0aa0c7cbe3d38fef4722f3f1d2d6c5f1}
Get Static Payload Size

\begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_a343e5d23477181011dea030fafb1954f}{set\+Payload\+Size()}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
The number of bytes in the payload 
\end{DoxyReturn}
\hypertarget{class_r_f24_a30c2736fd0df9c8128cef408c8b88e92}{\index{R\+F24@{R\+F24}!is\+Ack\+Payload\+Available@{is\+Ack\+Payload\+Available}}
\index{is\+Ack\+Payload\+Available@{is\+Ack\+Payload\+Available}!R\+F24@{R\+F24}}
\subsubsection[{is\+Ack\+Payload\+Available}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::is\+Ack\+Payload\+Available (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a30c2736fd0df9c8128cef408c8b88e92}
Determine if an ack payload was received in the most recent call to \hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()}. The regular \hyperlink{class_r_f24_a127105eb7a3b351cfe777c1cec50627a}{available()} can also be used.

Call \hyperlink{class_r_f24_a8e2eacacfba96426c192066f04054c5b}{read()} to retrieve the ack payload.

\begin{DoxyReturn}{Returns}
True if an ack payload is available. 
\end{DoxyReturn}
\hypertarget{class_r_f24_a62846750b82682beb7593719eb60ed60}{\index{R\+F24@{R\+F24}!is\+P\+Variant@{is\+P\+Variant}}
\index{is\+P\+Variant@{is\+P\+Variant}!R\+F24@{R\+F24}}
\subsubsection[{is\+P\+Variant}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::is\+P\+Variant (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a62846750b82682beb7593719eb60ed60}
Determine whether the hardware is an n\+R\+F24\+L01+ or not.

\begin{DoxyReturn}{Returns}
true if the hardware is n\+R\+F24\+L01+ (or compatible) and false if its not. 
\end{DoxyReturn}
\hypertarget{class_r_f24_a35e5f1533b7753806c42b76e782d917e}{\index{R\+F24@{R\+F24}!is\+Valid@{is\+Valid}}
\index{is\+Valid@{is\+Valid}!R\+F24@{R\+F24}}
\subsubsection[{is\+Valid}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::is\+Valid (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{class_r_f24_a35e5f1533b7753806c42b76e782d917e}
Test whether this is a real radio, or a mock shim for debugging. Setting either pin to 0xff is the way to indicate that this is not a real radio.

\begin{DoxyReturn}{Returns}
true if this is a legitimate radio 
\end{DoxyReturn}
\hypertarget{class_r_f24_abf68b9b0c9cd17179e9e144c3e7f9c45}{\index{R\+F24@{R\+F24}!mask\+I\+R\+Q@{mask\+I\+R\+Q}}
\index{mask\+I\+R\+Q@{mask\+I\+R\+Q}!R\+F24@{R\+F24}}
\subsubsection[{mask\+I\+R\+Q}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::mask\+I\+R\+Q (
\begin{DoxyParamCaption}
\item[{bool}]{tx\+\_\+ok, }
\item[{bool}]{tx\+\_\+fail, }
\item[{bool}]{rx\+\_\+ready}
\end{DoxyParamCaption}
)}}\label{class_r_f24_abf68b9b0c9cd17179e9e144c3e7f9c45}
The radio will generate interrupt signals when a transmission is complete, a transmission fails, or a payload is received. This allows users to mask those interrupts to prevent them from generating a signal on the interrupt pin.


\begin{DoxyCode}
Mask all interrupts except the receive interrupt:

radio.maskIRQ(1,1,0);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em tx\+\_\+ok} & Mask transmission complete interrupts \\
\hline
{\em tx\+\_\+fail} & Mask transmit failure interrupts \\
\hline
{\em rx\+\_\+ready} & Mask payload received interrupts \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a9edc910ccc1ffcff56814b08faca5535}{\index{R\+F24@{R\+F24}!open\+Reading\+Pipe@{open\+Reading\+Pipe}}
\index{open\+Reading\+Pipe@{open\+Reading\+Pipe}!R\+F24@{R\+F24}}
\subsubsection[{open\+Reading\+Pipe}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::open\+Reading\+Pipe (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{number, }
\item[{const uint8\+\_\+t $\ast$}]{address}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a9edc910ccc1ffcff56814b08faca5535}
Open a pipe for reading

Up to 6 pipes can be open for reading at once. Open all the reading pipes, and then call \hyperlink{class_r_f24_a30a2733a3889bdc331fe2d2f4f0f7b39}{start\+Listening()}.

\begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_af2e409e62d49a23e372a70b904ae30e1}{open\+Writing\+Pipe} 

\hyperlink{class_r_f24_ad5aea7f9a3bd9c7d357fb296ce751f21}{set\+Address\+Width}
\end{DoxySeeAlso}
\begin{DoxyWarning}{Warning}
Pipes 1-\/5 should share the same address, except the first byte. Only the first byte in the array should be unique, e.\+g. 
\begin{DoxyCode}
uint8\_t addresses[][6] = \{\textcolor{stringliteral}{"1Node"},\textcolor{stringliteral}{"2Node"}\};
\hyperlink{class_r_f24_a9edc910ccc1ffcff56814b08faca5535}{openReadingPipe}(1,addresses[0]);
\hyperlink{class_r_f24_a9edc910ccc1ffcff56814b08faca5535}{openReadingPipe}(2,addresses[1]);
\end{DoxyCode}


Pipe 0 is also used by the writing pipe. So if you open pipe 0 for reading, and then \hyperlink{class_r_f24_a30a2733a3889bdc331fe2d2f4f0f7b39}{start\+Listening()}, it will overwrite the writing pipe. Ergo, do an \hyperlink{class_r_f24_af2e409e62d49a23e372a70b904ae30e1}{open\+Writing\+Pipe()} again before \hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()}.
\end{DoxyWarning}

\begin{DoxyParams}{Parameters}
{\em number} & Which pipe\# to open, 0-\/5. \\
\hline
{\em address} & The 24, 32 or 40 bit address of the pipe to open. \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_aa7e8523f86f9f8f20c274e0c89a5fd45}{\index{R\+F24@{R\+F24}!open\+Reading\+Pipe@{open\+Reading\+Pipe}}
\index{open\+Reading\+Pipe@{open\+Reading\+Pipe}!R\+F24@{R\+F24}}
\subsubsection[{open\+Reading\+Pipe}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::open\+Reading\+Pipe (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{number, }
\item[{uint64\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{class_r_f24_aa7e8523f86f9f8f20c274e0c89a5fd45}
Open a pipe for reading \begin{DoxyNote}{Note}
For compatibility with old code only, see new function
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
Pipes 1-\/5 should share the first 32 bits. Only the least significant byte should be unique, e.\+g. 
\begin{DoxyCode}
\hyperlink{class_r_f24_a9edc910ccc1ffcff56814b08faca5535}{openReadingPipe}(1,0xF0F0F0F0AA);
\hyperlink{class_r_f24_a9edc910ccc1ffcff56814b08faca5535}{openReadingPipe}(2,0xF0F0F0F066);
\end{DoxyCode}


Pipe 0 is also used by the writing pipe. So if you open pipe 0 for reading, and then \hyperlink{class_r_f24_a30a2733a3889bdc331fe2d2f4f0f7b39}{start\+Listening()}, it will overwrite the writing pipe. Ergo, do an \hyperlink{class_r_f24_af2e409e62d49a23e372a70b904ae30e1}{open\+Writing\+Pipe()} again before \hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()}.
\end{DoxyWarning}

\begin{DoxyParams}{Parameters}
{\em number} & Which pipe\# to open, 0-\/5. \\
\hline
{\em address} & The 40-\/bit address of the pipe to open. \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_af2e409e62d49a23e372a70b904ae30e1}{\index{R\+F24@{R\+F24}!open\+Writing\+Pipe@{open\+Writing\+Pipe}}
\index{open\+Writing\+Pipe@{open\+Writing\+Pipe}!R\+F24@{R\+F24}}
\subsubsection[{open\+Writing\+Pipe}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::open\+Writing\+Pipe (
\begin{DoxyParamCaption}
\item[{const uint8\+\_\+t $\ast$}]{address}
\end{DoxyParamCaption}
)}}\label{class_r_f24_af2e409e62d49a23e372a70b904ae30e1}
New\+: Open a pipe for writing via byte array. Old addressing format retained for compatibility.

Only one writing pipe can be open at once, but you can change the address you'll write to. Call \hyperlink{class_r_f24_a6f144d73fc447c8ac2d1a4166210fd88}{stop\+Listening()} first.

Addresses are assigned via a byte array, default is 5 byte address length

Usage is exactly the same as before, except for declaring the array


\begin{DoxyCode}
uint8\_t addresses[][6] = \{\textcolor{stringliteral}{"1Node"},\textcolor{stringliteral}{"2Node"}\};
\hyperlink{class_r_f24_af2e409e62d49a23e372a70b904ae30e1}{openWritingPipe}(addresses[0]);
\end{DoxyCode}
 \begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_ad5aea7f9a3bd9c7d357fb296ce751f21}{set\+Address\+Width}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em address} & The address of the pipe to open. Coordinate these pipe addresses amongst nodes on the network. \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a50c8e68ee840e1860a31dbdc83afbd77}{\index{R\+F24@{R\+F24}!open\+Writing\+Pipe@{open\+Writing\+Pipe}}
\index{open\+Writing\+Pipe@{open\+Writing\+Pipe}!R\+F24@{R\+F24}}
\subsubsection[{open\+Writing\+Pipe}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::open\+Writing\+Pipe (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{address}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a50c8e68ee840e1860a31dbdc83afbd77}
Open a pipe for writing \begin{DoxyNote}{Note}
For compatibility with old code only, see new function Addresses are 40-\/bit hex values, e.\+g.\+:
\end{DoxyNote}

\begin{DoxyCode}
\hyperlink{class_r_f24_af2e409e62d49a23e372a70b904ae30e1}{openWritingPipe}(0xF0F0F0F0F0);
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em address} & The 40-\/bit address of the pipe to open. \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_aa0a51923a09ba4f3478aba9be0f8a6a1}{\index{R\+F24@{R\+F24}!power\+Down@{power\+Down}}
\index{power\+Down@{power\+Down}!R\+F24@{R\+F24}}
\subsubsection[{power\+Down}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::power\+Down (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_aa0a51923a09ba4f3478aba9be0f8a6a1}
Enter low-\/power mode

To return to normal power mode, either \hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()} some data or start\+Listening, or \hyperlink{class_r_f24_a5cdaf47aa0edd6dca1b9a8bb7972a1a3}{power\+Up()}.

\begin{DoxyNote}{Note}
After calling \hyperlink{class_r_f24_a30a2733a3889bdc331fe2d2f4f0f7b39}{start\+Listening()}, a basic radio will consume about 13.\+5m\+A at max P\+A level. During active transmission, the radio will consume about 11.\+5m\+A, but this will be reduced to 26u\+A (.026m\+A) between sending. In full power\+Down mode, the radio will consume approximately 900n\+A (.0009m\+A) 
\end{DoxyNote}
\hypertarget{class_r_f24_a5cdaf47aa0edd6dca1b9a8bb7972a1a3}{\index{R\+F24@{R\+F24}!power\+Up@{power\+Up}}
\index{power\+Up@{power\+Up}!R\+F24@{R\+F24}}
\subsubsection[{power\+Up}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::power\+Up (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a5cdaf47aa0edd6dca1b9a8bb7972a1a3}
Leave low-\/power mode -\/ required for normal radio operation after calling \hyperlink{class_r_f24_aa0a51923a09ba4f3478aba9be0f8a6a1}{power\+Down()}

To return to low power mode, call \hyperlink{class_r_f24_aa0a51923a09ba4f3478aba9be0f8a6a1}{power\+Down()}. \begin{DoxyNote}{Note}
This will take up to 5ms for maximum compatibility 
\end{DoxyNote}
\hypertarget{class_r_f24_adc95213ed4c8569a90eb33122e16cea6}{\index{R\+F24@{R\+F24}!print\+Details@{print\+Details}}
\index{print\+Details@{print\+Details}!R\+F24@{R\+F24}}
\subsubsection[{print\+Details}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::print\+Details (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_adc95213ed4c8569a90eb33122e16cea6}
Print a giant block of debugging information to stdout

\begin{DoxyWarning}{Warning}
Does nothing if stdout is not defined. See fdevopen in stdio.\+h 
\end{DoxyWarning}
\hypertarget{class_r_f24_a8e2eacacfba96426c192066f04054c5b}{\index{R\+F24@{R\+F24}!read@{read}}
\index{read@{read}!R\+F24@{R\+F24}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::read (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{buf, }
\item[{uint8\+\_\+t}]{len}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a8e2eacacfba96426c192066f04054c5b}
Read the payload

The size of data read is the fixed payload size, see \hyperlink{class_r_f24_a0aa0c7cbe3d38fef4722f3f1d2d6c5f1}{get\+Payload\+Size()}

\begin{DoxyNote}{Note}
I specifically chose 'void$\ast$' as a data type to make it easier for beginners to use. No casting needed.

No longer boolean. Use available to determine if packets are available. Interrupt flags are now cleared during reads instead of when calling \hyperlink{class_r_f24_a127105eb7a3b351cfe777c1cec50627a}{available()}.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em buf} & Pointer to a buffer where the data should be written \\
\hline
{\em len} & Maximum number of bytes to read into the buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
No return value. Use \hyperlink{class_r_f24_a127105eb7a3b351cfe777c1cec50627a}{available()}. 
\end{DoxyReturn}
\hypertarget{class_r_f24_aeaf7fa54d3ab2a85ce215b4bf6ae933b}{\index{R\+F24@{R\+F24}!re\+Use\+T\+X@{re\+Use\+T\+X}}
\index{re\+Use\+T\+X@{re\+Use\+T\+X}!R\+F24@{R\+F24}}
\subsubsection[{re\+Use\+T\+X}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::re\+Use\+T\+X (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_aeaf7fa54d3ab2a85ce215b4bf6ae933b}
This function is mainly used internally to take advantage of the auto payload re-\/use functionality of the chip, but can be beneficial to users as well.

The function will instruct the radio to re-\/use the data in the F\+I\+F\+O buffers, and instructs the radio to re-\/send once the timeout limit has been reached. Used by write\+Fast and write\+Blocking to initiate retries when a T\+X failure occurs. Retries are automatically initiated except with the standard \hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()}. This way, data is not flushed from the buffer until switching between modes.

\begin{DoxyNote}{Note}
This is to be used A\+F\+T\+E\+R auto-\/retry fails if wanting to resend using the built-\/in payload reuse features. After issuing \hyperlink{class_r_f24_aeaf7fa54d3ab2a85ce215b4bf6ae933b}{re\+Use\+T\+X()}, it will keep reending the same payload forever or until a payload is written to the F\+I\+F\+O, or a flush\+\_\+tx command is given. 
\end{DoxyNote}
\hypertarget{class_r_f24_ad22e44fe1a68747872fcb304a407fd30}{\index{R\+F24@{R\+F24}!rx\+Fifo\+Full@{rx\+Fifo\+Full}}
\index{rx\+Fifo\+Full@{rx\+Fifo\+Full}!R\+F24@{R\+F24}}
\subsubsection[{rx\+Fifo\+Full}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::rx\+Fifo\+Full (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_ad22e44fe1a68747872fcb304a407fd30}
Check if the radio needs to be read. Can be used to prevent data loss @return True if all three 32-\/byte radio buffers are full \hypertarget{class_r_f24_ad5aea7f9a3bd9c7d357fb296ce751f21}{\index{R\+F24@{R\+F24}!set\+Address\+Width@{set\+Address\+Width}}
\index{set\+Address\+Width@{set\+Address\+Width}!R\+F24@{R\+F24}}
\subsubsection[{set\+Address\+Width}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::set\+Address\+Width (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{a\+\_\+width}
\end{DoxyParamCaption}
)}}\label{class_r_f24_ad5aea7f9a3bd9c7d357fb296ce751f21}
Set the address width from 3 to 5 bytes (24, 32 or 40 bit)


\begin{DoxyParams}{Parameters}
{\em a\+\_\+width} & The address width to use\+: 3,4 or 5 \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_aec71746d59da978bcbb975167886a2cc}{\index{R\+F24@{R\+F24}!set\+Auto\+Ack@{set\+Auto\+Ack}}
\index{set\+Auto\+Ack@{set\+Auto\+Ack}!R\+F24@{R\+F24}}
\subsubsection[{set\+Auto\+Ack}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::set\+Auto\+Ack (
\begin{DoxyParamCaption}
\item[{bool}]{enable}
\end{DoxyParamCaption}
)}}\label{class_r_f24_aec71746d59da978bcbb975167886a2cc}
Enable or disable auto-\/acknowlede packets

This is enabled by default, so it's only needed if you want to turn it off for some reason.


\begin{DoxyParams}{Parameters}
{\em enable} & Whether to enable (true) or disable (false) auto-\/acks \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a60dba9e558f3620ab489af68ea3dea9c}{\index{R\+F24@{R\+F24}!set\+Auto\+Ack@{set\+Auto\+Ack}}
\index{set\+Auto\+Ack@{set\+Auto\+Ack}!R\+F24@{R\+F24}}
\subsubsection[{set\+Auto\+Ack}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::set\+Auto\+Ack (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{pipe, }
\item[{bool}]{enable}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a60dba9e558f3620ab489af68ea3dea9c}
Enable or disable auto-\/acknowlede packets on a per pipeline basis.

A\+A is enabled by default, so it's only needed if you want to turn it off/on for some reason on a per pipeline basis.


\begin{DoxyParams}{Parameters}
{\em pipe} & Which pipeline to modify \\
\hline
{\em enable} & Whether to enable (true) or disable (false) auto-\/acks \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a5e6e5a5f6c85d2638381cab2c0f3702e}{\index{R\+F24@{R\+F24}!set\+Channel@{set\+Channel}}
\index{set\+Channel@{set\+Channel}!R\+F24@{R\+F24}}
\subsubsection[{set\+Channel}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::set\+Channel (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{channel}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a5e6e5a5f6c85d2638381cab2c0f3702e}
Set R\+F communication channel


\begin{DoxyParams}{Parameters}
{\em channel} & Which R\+F channel to communicate on, 0-\/127 \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a89f626fc4a58dd997153bcc0f8198b9e}{\index{R\+F24@{R\+F24}!set\+C\+R\+C\+Length@{set\+C\+R\+C\+Length}}
\index{set\+C\+R\+C\+Length@{set\+C\+R\+C\+Length}!R\+F24@{R\+F24}}
\subsubsection[{set\+C\+R\+C\+Length}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::set\+C\+R\+C\+Length (
\begin{DoxyParamCaption}
\item[{{\bf rf24\+\_\+crclength\+\_\+e}}]{length}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a89f626fc4a58dd997153bcc0f8198b9e}
Set the C\+R\+C length


\begin{DoxyParams}{Parameters}
{\em length} & R\+F24\+\_\+\+C\+R\+C\+\_\+8 for 8-\/bit or R\+F24\+\_\+\+C\+R\+C\+\_\+16 for 16-\/bit \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_aeb9920e7a95699748b003c4a839b0814}{\index{R\+F24@{R\+F24}!set\+Data\+Rate@{set\+Data\+Rate}}
\index{set\+Data\+Rate@{set\+Data\+Rate}!R\+F24@{R\+F24}}
\subsubsection[{set\+Data\+Rate}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::set\+Data\+Rate (
\begin{DoxyParamCaption}
\item[{{\bf rf24\+\_\+datarate\+\_\+e}}]{speed}
\end{DoxyParamCaption}
)}}\label{class_r_f24_aeb9920e7a95699748b003c4a839b0814}
Set the transmission data rate

\begin{DoxyWarning}{Warning}
setting R\+F24\+\_\+250\+K\+B\+P\+S will fail for non-\/plus units
\end{DoxyWarning}

\begin{DoxyParams}{Parameters}
{\em speed} & R\+F24\+\_\+250\+K\+B\+P\+S for 250kbs, R\+F24\+\_\+1\+M\+B\+P\+S for 1\+Mbps, or R\+F24\+\_\+2\+M\+B\+P\+S for 2\+Mbps \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the change was successful 
\end{DoxyReturn}
\hypertarget{class_r_f24_adedac579590a668ae97baccab284de8a}{\index{R\+F24@{R\+F24}!set\+P\+A\+Level@{set\+P\+A\+Level}}
\index{set\+P\+A\+Level@{set\+P\+A\+Level}!R\+F24@{R\+F24}}
\subsubsection[{set\+P\+A\+Level}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::set\+P\+A\+Level (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{level}
\end{DoxyParamCaption}
)}}\label{class_r_f24_adedac579590a668ae97baccab284de8a}
Set Power Amplifier (P\+A) level to one of four levels\+: R\+F24\+\_\+\+P\+A\+\_\+\+M\+I\+N, R\+F24\+\_\+\+P\+A\+\_\+\+L\+O\+W, R\+F24\+\_\+\+P\+A\+\_\+\+H\+I\+G\+H and R\+F24\+\_\+\+P\+A\+\_\+\+M\+A\+X

The power levels correspond to the following output levels respectively\+: N\+R\+F24\+L01\+: -\/18d\+Bm, -\/12d\+Bm,-\/6d\+B\+M, and 0d\+Bm

S\+I24\+R1\+: -\/6d\+Bm, 0d\+Bm, 3d\+B\+M, and 7d\+Bm.


\begin{DoxyParams}{Parameters}
{\em level} & Desired P\+A level. \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a343e5d23477181011dea030fafb1954f}{\index{R\+F24@{R\+F24}!set\+Payload\+Size@{set\+Payload\+Size}}
\index{set\+Payload\+Size@{set\+Payload\+Size}!R\+F24@{R\+F24}}
\subsubsection[{set\+Payload\+Size}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::set\+Payload\+Size (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{size}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a343e5d23477181011dea030fafb1954f}
Set Static Payload Size

This implementation uses a pre-\/stablished fixed payload size for all transmissions. If this method is never called, the driver will always transmit the maximum payload size (32 bytes), no matter how much was sent to \hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()}.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000001}{Todo}]Implement variable-\/sized payloads feature\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em size} & The number of bytes in the payload \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a4c6d3959c8320e64568395f4ef507aef}{\index{R\+F24@{R\+F24}!set\+Retries@{set\+Retries}}
\index{set\+Retries@{set\+Retries}!R\+F24@{R\+F24}}
\subsubsection[{set\+Retries}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::set\+Retries (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{delay, }
\item[{uint8\+\_\+t}]{count}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a4c6d3959c8320e64568395f4ef507aef}
Set the number and delay of retries upon failed submit


\begin{DoxyParams}{Parameters}
{\em delay} & How long to wait between each retry, in multiples of 250us, max is 15. 0 means 250us, 15 means 4000us. \\
\hline
{\em count} & How many retries before giving up, max 15 \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a7f27a53cda5f707c817c9a89a8425489}{\index{R\+F24@{R\+F24}!start\+Fast\+Write@{start\+Fast\+Write}}
\index{start\+Fast\+Write@{start\+Fast\+Write}!R\+F24@{R\+F24}}
\subsubsection[{start\+Fast\+Write}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::start\+Fast\+Write (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{buf, }
\item[{uint8\+\_\+t}]{len, }
\item[{const bool}]{multicast}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a7f27a53cda5f707c817c9a89a8425489}
Non-\/blocking write to the open writing pipe used for buffered writes

\begin{DoxyNote}{Note}
Optimization\+: This function now leaves the C\+E pin high, so the radio will remain in T\+X or S\+T\+A\+N\+D\+B\+Y-\/\+I\+I Mode until a \hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{tx\+Stand\+By()} command is issued. This allows the chip to be used to its full potential in T\+X mode. 
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
It is important to never keep the n\+R\+F24\+L01 in T\+X mode with F\+I\+F\+O full for more than 4ms at a time. If the auto retransmit is enabled, the n\+R\+F24\+L01 is never in T\+X mode long enough to disobey this rule. Allow the F\+I\+F\+O to clear by issuing \hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{tx\+Stand\+By()} or ensure appropriate time between transmissions.
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()} 

\hyperlink{class_r_f24_a47b2516993481b58e724d1274a7fd9cb}{write\+Fast()} 

\hyperlink{class_r_f24_aa27519fc289920094422033e0bbf8cf9}{start\+Write()} 

\hyperlink{class_r_f24_ae6fd8d5ee490d54ae1cb2e8fefee535f}{write\+Blocking()}
\end{DoxySeeAlso}
For single no\+Ack writes see\+: \begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_a6253607ac2a1995af91a35cea6899c31}{enable\+Dynamic\+Ack()} 

\hyperlink{class_r_f24_aec71746d59da978bcbb975167886a2cc}{set\+Auto\+Ack()}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em buf} & Pointer to the data to be sent \\
\hline
{\em len} & Number of bytes to be sent \\
\hline
{\em multicast} & Request A\+C\+K (0) or N\+O\+A\+C\+K (1) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the payload was delivered successfully false if not 
\end{DoxyReturn}
\hypertarget{class_r_f24_a30a2733a3889bdc331fe2d2f4f0f7b39}{\index{R\+F24@{R\+F24}!start\+Listening@{start\+Listening}}
\index{start\+Listening@{start\+Listening}!R\+F24@{R\+F24}}
\subsubsection[{start\+Listening}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::start\+Listening (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a30a2733a3889bdc331fe2d2f4f0f7b39}
Start listening on the pipes opened for reading.

Be sure to call \hyperlink{class_r_f24_a9edc910ccc1ffcff56814b08faca5535}{open\+Reading\+Pipe()} first. Do not call \hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()} while in this mode, without first calling \hyperlink{class_r_f24_a6f144d73fc447c8ac2d1a4166210fd88}{stop\+Listening()}. Call Available() to check for incoming traffic, and \hyperlink{class_r_f24_a8e2eacacfba96426c192066f04054c5b}{read()} to get it. \hypertarget{class_r_f24_aa27519fc289920094422033e0bbf8cf9}{\index{R\+F24@{R\+F24}!start\+Write@{start\+Write}}
\index{start\+Write@{start\+Write}!R\+F24@{R\+F24}}
\subsubsection[{start\+Write}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::start\+Write (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{buf, }
\item[{uint8\+\_\+t}]{len, }
\item[{const bool}]{multicast}
\end{DoxyParamCaption}
)}}\label{class_r_f24_aa27519fc289920094422033e0bbf8cf9}
Non-\/blocking write to the open writing pipe

Just like \hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()}, but it returns immediately. To find out what happened to the send, catch the I\+R\+Q and then call \hyperlink{class_r_f24_afb97dc4bdf4d2d84ea44060ac5b4ed89}{what\+Happened()}.

\begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()} 

\hyperlink{class_r_f24_a47b2516993481b58e724d1274a7fd9cb}{write\+Fast()} 

\hyperlink{class_r_f24_a7f27a53cda5f707c817c9a89a8425489}{start\+Fast\+Write()} 

\hyperlink{class_r_f24_afb97dc4bdf4d2d84ea44060ac5b4ed89}{what\+Happened()}
\end{DoxySeeAlso}
For single no\+Ack writes see\+: \begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_a6253607ac2a1995af91a35cea6899c31}{enable\+Dynamic\+Ack()} 

\hyperlink{class_r_f24_aec71746d59da978bcbb975167886a2cc}{set\+Auto\+Ack()}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em buf} & Pointer to the data to be sent \\
\hline
{\em len} & Number of bytes to be sent \\
\hline
{\em multicast} & Request A\+C\+K (0) or N\+O\+A\+C\+K (1) \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a6f144d73fc447c8ac2d1a4166210fd88}{\index{R\+F24@{R\+F24}!stop\+Listening@{stop\+Listening}}
\index{stop\+Listening@{stop\+Listening}!R\+F24@{R\+F24}}
\subsubsection[{stop\+Listening}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::stop\+Listening (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a6f144d73fc447c8ac2d1a4166210fd88}
Stop listening for incoming messages

Do this before calling \hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()}. \hypertarget{class_r_f24_ad0d522ccf39493510e64bf1740be790d}{\index{R\+F24@{R\+F24}!test\+Carrier@{test\+Carrier}}
\index{test\+Carrier@{test\+Carrier}!R\+F24@{R\+F24}}
\subsubsection[{test\+Carrier}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::test\+Carrier (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_ad0d522ccf39493510e64bf1740be790d}
Test whether there was a carrier on the line for the previous listening period.

Useful to check for interference on the current channel.

\begin{DoxyReturn}{Returns}
true if was carrier, false if not 
\end{DoxyReturn}
\hypertarget{class_r_f24_a821285f3b54553f4402eb3fd0ac6d6c1}{\index{R\+F24@{R\+F24}!test\+R\+P\+D@{test\+R\+P\+D}}
\index{test\+R\+P\+D@{test\+R\+P\+D}!R\+F24@{R\+F24}}
\subsubsection[{test\+R\+P\+D}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::test\+R\+P\+D (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a821285f3b54553f4402eb3fd0ac6d6c1}
Test whether a signal (carrier or otherwise) greater than or equal to -\/64d\+Bm is present on the channel. Valid only on n\+R\+F24\+L01\+P (+) hardware. On n\+R\+F24\+L01, use \hyperlink{class_r_f24_ad0d522ccf39493510e64bf1740be790d}{test\+Carrier()}.

Useful to check for interference on the current channel and channel hopping strategies.

\begin{DoxyReturn}{Returns}
true if signal =$>$ -\/64d\+Bm, false if not 
\end{DoxyReturn}
\hypertarget{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{\index{R\+F24@{R\+F24}!tx\+Stand\+By@{tx\+Stand\+By}}
\index{tx\+Stand\+By@{tx\+Stand\+By}!R\+F24@{R\+F24}}
\subsubsection[{tx\+Stand\+By}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::tx\+Stand\+By (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}
This function should be called as soon as transmission is finished to drop the radio back to S\+T\+A\+N\+D\+B\+Y-\/\+I mode. If not issued, the radio will remain in S\+T\+A\+N\+D\+B\+Y-\/\+I\+I mode which, per the data sheet, is not a recommended operating mode.

\begin{DoxyNote}{Note}
When transmitting data in rapid succession, it is still recommended by the manufacturer to drop the radio out of T\+X or S\+T\+A\+N\+D\+B\+Y-\/\+I\+I mode if there is time enough between sends for the F\+I\+F\+Os to empty.
\end{DoxyNote}
Relies on built-\/in auto retry functionality.


\begin{DoxyCode}
Example (Partial blocking):

        radio.\hyperlink{class_r_f24_a47b2516993481b58e724d1274a7fd9cb}{writeFast}(&buf,32);
        radio.writeFast(&buf,32);
        radio.writeFast(&buf,32);  \textcolor{comment}{//Fills the FIFO buffers up}
        \textcolor{keywordtype}{bool} ok = \hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{txStandBy}();     \textcolor{comment}{//Returns 0 if failed. 1 if success.}
                                   \textcolor{comment}{//Blocks only until MAX\_RT timeout or success. Data flushed on fail.}
\end{DoxyCode}
 \begin{DoxySeeAlso}{See also}
tx\+Stand\+By(unsigned long timeout) 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
True if transmission is successful 
\end{DoxyReturn}
\hypertarget{class_r_f24_aa6f36353c1bdfbaf3c530d118cb84baa}{\index{R\+F24@{R\+F24}!tx\+Stand\+By@{tx\+Stand\+By}}
\index{tx\+Stand\+By@{tx\+Stand\+By}!R\+F24@{R\+F24}}
\subsubsection[{tx\+Stand\+By}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::tx\+Stand\+By (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{timeout}
\end{DoxyParamCaption}
)}}\label{class_r_f24_aa6f36353c1bdfbaf3c530d118cb84baa}
This function allows extended blocking and auto-\/retries per a user defined timeout 
\begin{DoxyCode}
Fully Blocking Example:

     radio.writeFast(&buf,32);
     radio.writeFast(&buf,32);
     radio.writeFast(&buf,32);   \textcolor{comment}{//Fills the FIFO buffers up}
     \textcolor{keywordtype}{bool} ok = \hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{txStandBy}(1000);  \textcolor{comment}{//Returns 0 if failed after 1 second of retries. 1 if success.}
                                 \textcolor{comment}{//Blocks only until user defined timeout or success. Data flushed on fail.}
\end{DoxyCode}
 \begin{DoxyNote}{Note}
If used from within an interrupt, the interrupt should be disabled until completion, and sei(); called to enable millis(). 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em timeout} & Number of milliseconds to retry failed payloads \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if transmission is successful 
\end{DoxyReturn}
\hypertarget{class_r_f24_afb97dc4bdf4d2d84ea44060ac5b4ed89}{\index{R\+F24@{R\+F24}!what\+Happened@{what\+Happened}}
\index{what\+Happened@{what\+Happened}!R\+F24@{R\+F24}}
\subsubsection[{what\+Happened}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::what\+Happened (
\begin{DoxyParamCaption}
\item[{bool \&}]{tx\+\_\+ok, }
\item[{bool \&}]{tx\+\_\+fail, }
\item[{bool \&}]{rx\+\_\+ready}
\end{DoxyParamCaption}
)}}\label{class_r_f24_afb97dc4bdf4d2d84ea44060ac5b4ed89}
Call this when you get an interrupt to find out why

Tells you what caused the interrupt, and clears the state of interrupts.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em tx\+\_\+ok} & The send was successful (T\+X\+\_\+\+D\+S) \\
\hline
\mbox{\tt out}  & {\em tx\+\_\+fail} & The send failed, too many retries (M\+A\+X\+\_\+\+R\+T) \\
\hline
\mbox{\tt out}  & {\em rx\+\_\+ready} & There is a message waiting to be read (R\+X\+\_\+\+D\+S) \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{\index{R\+F24@{R\+F24}!write@{write}}
\index{write@{write}!R\+F24@{R\+F24}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::write (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{buf, }
\item[{uint8\+\_\+t}]{len}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}
Be sure to call \hyperlink{class_r_f24_af2e409e62d49a23e372a70b904ae30e1}{open\+Writing\+Pipe()} first to set the destination of where to write to.

This blocks until the message is successfully acknowledged by the receiver or the timeout/retransmit maxima are reached. In the current configuration, the max delay here is 60-\/70ms.

The maximum size of data written is the fixed payload size, see \hyperlink{class_r_f24_a0aa0c7cbe3d38fef4722f3f1d2d6c5f1}{get\+Payload\+Size()}. However, you can write less, and the remainder will just be filled with zeroes.

T\+X/\+R\+X/\+R\+T interrupt flags will be cleared every time write is called


\begin{DoxyParams}{Parameters}
{\em buf} & Pointer to the data to be sent \\
\hline
{\em len} & Number of bytes to be sent \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the payload was delivered successfully false if not 
\end{DoxyReturn}
\hypertarget{class_r_f24_a23bfe6502d74bb5bbccb3a7f2ba2b5ea}{\index{R\+F24@{R\+F24}!write@{write}}
\index{write@{write}!R\+F24@{R\+F24}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::write (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{buf, }
\item[{uint8\+\_\+t}]{len, }
\item[{const bool}]{multicast}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a23bfe6502d74bb5bbccb3a7f2ba2b5ea}
Write for single N\+O\+A\+C\+K writes. Optionally disables acknowledgements/autoretries for a single write.

\begin{DoxyNote}{Note}
\hyperlink{class_r_f24_a6253607ac2a1995af91a35cea6899c31}{enable\+Dynamic\+Ack()} must be called to enable this feature
\end{DoxyNote}
Can be used with \hyperlink{class_r_f24_abf8efced2ee9edbcc6510878b20edc1b}{enable\+Ack\+Payload()} to request a response \begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_a6253607ac2a1995af91a35cea6899c31}{enable\+Dynamic\+Ack()} 

\hyperlink{class_r_f24_aec71746d59da978bcbb975167886a2cc}{set\+Auto\+Ack()} 

\hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em buf} & Pointer to the data to be sent \\
\hline
{\em len} & Number of bytes to be sent \\
\hline
{\em multicast} & Request A\+C\+K (0), N\+O\+A\+C\+K (1) \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_a65619238c25036c3de72dc2c1a1c6e52}{\index{R\+F24@{R\+F24}!write\+Ack\+Payload@{write\+Ack\+Payload}}
\index{write\+Ack\+Payload@{write\+Ack\+Payload}!R\+F24@{R\+F24}}
\subsubsection[{write\+Ack\+Payload}]{\setlength{\rightskip}{0pt plus 5cm}void R\+F24\+::write\+Ack\+Payload (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{pipe, }
\item[{const void $\ast$}]{buf, }
\item[{uint8\+\_\+t}]{len}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a65619238c25036c3de72dc2c1a1c6e52}
Write an ack payload for the specified pipe

The next time a message is received on {\ttfamily pipe}, the data in {\ttfamily buf} will be sent back in the acknowledgement.

\begin{DoxyWarning}{Warning}
Only three of these can be pending at any time as there are only 3 F\+I\+F\+O buffers.
\end{DoxyWarning}

\begin{DoxyParams}{Parameters}
{\em pipe} & Which pipe\# (typically 1-\/5) will get this response. \\
\hline
{\em buf} & Pointer to data that is sent \\
\hline
{\em len} & Length of the data to send, up to 32 bytes max. Not affected by the static payload set by \hyperlink{class_r_f24_a343e5d23477181011dea030fafb1954f}{set\+Payload\+Size()}. \\
\hline
\end{DoxyParams}
\hypertarget{class_r_f24_ae6fd8d5ee490d54ae1cb2e8fefee535f}{\index{R\+F24@{R\+F24}!write\+Blocking@{write\+Blocking}}
\index{write\+Blocking@{write\+Blocking}!R\+F24@{R\+F24}}
\subsubsection[{write\+Blocking}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::write\+Blocking (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{buf, }
\item[{uint8\+\_\+t}]{len, }
\item[{uint32\+\_\+t}]{timeout}
\end{DoxyParamCaption}
)}}\label{class_r_f24_ae6fd8d5ee490d54ae1cb2e8fefee535f}
This function extends the auto-\/retry mechanism to any specified duration. It will not block until the 3 F\+I\+F\+O buffers are filled with data. If so the library will auto retry until a new payload is written or the user specified timeout period is reached. \begin{DoxyWarning}{Warning}
It is important to never keep the n\+R\+F24\+L01 in T\+X mode and F\+I\+F\+O full for more than 4ms at a time. If the auto retransmit is enabled, the n\+R\+F24\+L01 is never in T\+X mode long enough to disobey this rule. Allow the F\+I\+F\+O to clear by issuing \hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{tx\+Stand\+By()} or ensure appropriate time between transmissions.
\end{DoxyWarning}
O\+N\+L\+Y max retry interrupt flags will be cleared when write\+Blocking is called 
\begin{DoxyCode}
Example (Full blocking):

        radio.\hyperlink{class_r_f24_ae6fd8d5ee490d54ae1cb2e8fefee535f}{writeBlocking}(&buf,32,1000); \textcolor{comment}{//Wait up to 1 second to write 1 payload to the
       buffers}
        \hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{txStandBy}(1000);                   \textcolor{comment}{//Wait up to 1 second for the payload to send. Return 1
       if ok, 0 if failed.}
                                           \textcolor{comment}{//Blocks only until user timeout or success. Data flushed on
       fail.}
\end{DoxyCode}
 \begin{DoxyNote}{Note}
If used from within an interrupt, the interrupt should be disabled until completion, and sei(); called to enable millis(). 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{tx\+Stand\+By()} 

\hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()} 

\hyperlink{class_r_f24_a47b2516993481b58e724d1274a7fd9cb}{write\+Fast()}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em buf} & Pointer to the data to be sent \\
\hline
{\em len} & Number of bytes to be sent \\
\hline
{\em timeout} & User defined timeout in milliseconds. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the payload was loaded into the buffer successfully false if not 
\end{DoxyReturn}
\hypertarget{class_r_f24_a47b2516993481b58e724d1274a7fd9cb}{\index{R\+F24@{R\+F24}!write\+Fast@{write\+Fast}}
\index{write\+Fast@{write\+Fast}!R\+F24@{R\+F24}}
\subsubsection[{write\+Fast}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::write\+Fast (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{buf, }
\item[{uint8\+\_\+t}]{len}
\end{DoxyParamCaption}
)}}\label{class_r_f24_a47b2516993481b58e724d1274a7fd9cb}
This will not block until the 3 F\+I\+F\+O buffers are filled with data. Once the F\+I\+F\+Os are full, write\+Fast will simply wait for success or timeout, and return 1 or 0 respectively. From a user perspective, just keep trying to send the same data. The library will keep auto retrying the current payload using the built in functionality. \begin{DoxyWarning}{Warning}
It is important to never keep the n\+R\+F24\+L01 in T\+X mode and F\+I\+F\+O full for more than 4ms at a time. If the auto retransmit is enabled, the n\+R\+F24\+L01 is never in T\+X mode long enough to disobey this rule. Allow the F\+I\+F\+O to clear by issuing \hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{tx\+Stand\+By()} or ensure appropriate time between transmissions.
\end{DoxyWarning}
O\+N\+L\+Y max retry interrupt flags will be cleared when write\+Fast is called


\begin{DoxyCode}
Example (Partial blocking):

        radio.\hyperlink{class_r_f24_a47b2516993481b58e724d1274a7fd9cb}{writeFast}(&buf,32);  \textcolor{comment}{// Writes 1 payload to the buffers}
        \hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{txStandBy}();               \textcolor{comment}{// Returns 0 if failed. 1 if success. Blocks only until MAX\_RT
       timeout or success. Data flushed on fail.}

        radio.writeFast(&buf,32);  \textcolor{comment}{// Writes 1 payload to the buffers}
        \hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{txStandBy}(1000);           \textcolor{comment}{// Using extended timeouts, returns 1 if success. Retries
       failed payloads for 1 seconds before returning 0.}
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_a12cc453453c94969d4d3f0edb3778c83}{tx\+Stand\+By()} 

\hyperlink{class_r_f24_a4cd4c198a47704db20b6b5cf0731cd58}{write()} 

\hyperlink{class_r_f24_ae6fd8d5ee490d54ae1cb2e8fefee535f}{write\+Blocking()}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em buf} & Pointer to the data to be sent \\
\hline
{\em len} & Number of bytes to be sent \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the payload was delivered successfully false if not 
\end{DoxyReturn}
\hypertarget{class_r_f24_ad16d53de0327c0b41d170cbda4bf41af}{\index{R\+F24@{R\+F24}!write\+Fast@{write\+Fast}}
\index{write\+Fast@{write\+Fast}!R\+F24@{R\+F24}}
\subsubsection[{write\+Fast}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::write\+Fast (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{buf, }
\item[{uint8\+\_\+t}]{len, }
\item[{const bool}]{multicast}
\end{DoxyParamCaption}
)}}\label{class_r_f24_ad16d53de0327c0b41d170cbda4bf41af}
Write\+Fast for single N\+O\+A\+C\+K writes. Disables acknowledgements/autoretries for a single write.

\begin{DoxyNote}{Note}
\hyperlink{class_r_f24_a6253607ac2a1995af91a35cea6899c31}{enable\+Dynamic\+Ack()} must be called to enable this feature 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{class_r_f24_a6253607ac2a1995af91a35cea6899c31}{enable\+Dynamic\+Ack()} 

\hyperlink{class_r_f24_aec71746d59da978bcbb975167886a2cc}{set\+Auto\+Ack()}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em buf} & Pointer to the data to be sent \\
\hline
{\em len} & Number of bytes to be sent \\
\hline
{\em multicast} & Request A\+C\+K (0) or N\+O\+A\+C\+K (1) \\
\hline
\end{DoxyParams}


\subsection{Member Data Documentation}
\hypertarget{class_r_f24_a2e40fe66d1231a333aa2534e8491f828}{\index{R\+F24@{R\+F24}!failure\+Detected@{failure\+Detected}}
\index{failure\+Detected@{failure\+Detected}!R\+F24@{R\+F24}}
\subsubsection[{failure\+Detected}]{\setlength{\rightskip}{0pt plus 5cm}bool R\+F24\+::failure\+Detected}}\label{class_r_f24_a2e40fe66d1231a333aa2534e8491f828}
Enable error detection by un-\/commenting \#define F\+A\+I\+L\+U\+R\+E\+\_\+\+H\+A\+N\+D\+L\+I\+N\+G in \hyperlink{_r_f24__config_8h_source}{R\+F24\+\_\+config.\+h} If a failure has been detected, it usually indicates a hardware issue. By default the library will cease operation when a failure is detected. This should allow advanced users to detect and resolve intermittent hardware issues.

In most cases, the radio must be re-\/enabled via radio.\+begin(); and the appropriate settings applied after a failure occurs, if wanting to re-\/enable the device immediately.

Usage\+: (Failure handling must be enabled per above) 
\begin{DoxyCode}
\textcolor{keywordflow}{if}(radio.failureDetected)\{ 
  radio.begin();                        \textcolor{comment}{// Attempt to re-configure the radio with defaults}
  radio.failureDetected = 0;            \textcolor{comment}{// Reset the detection value}
  radio.openWritingPipe(addresses[1]); \textcolor{comment}{// Re-configure pipe addresses}
  radio.openReadingPipe(1,addresses[0]);
  report\_failure();                 \textcolor{comment}{// Blink leds, send a message, etc. to indicate failure}
\}
\end{DoxyCode}
 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{_r_f24_8h}{R\+F24.\+h}\item 
R\+F24.\+cpp\end{DoxyCompactItemize}
